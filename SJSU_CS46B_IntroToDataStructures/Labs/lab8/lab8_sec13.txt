Jake Lepere – DriveJohnny Chi – Scribe10-16-2015lab8PartA1.The program takes progressively longer to execute2.100000 3s   200000 7s   300000 15s   400000 22s3.1   1s   2   2.5s   3   5s   4   7.33s4.This curve is linear (our 400000 time is slightly off)5.The for loops are inpedendent of eachother6.I expect this the program to run faster7. 100000 .5s    200000 .5s    300000 .75s    400000 1s    10000000 5sPartB1.$418K $439K $338K $410K $389K $405K $398K $388K $404K    $338K $388K $398K $298K $404K $405K $410K $418K $439K    Median: $404K2.In Collections class I would call the max and the min method    In the List class I would call the remove with an object parameter to remove the first occurance of the object.3. import java.util.Collections;import java.util.List;import java.util.ArrayList;public class Median1{   public static void main(String[] args)   {      int n = Integer.parseInt(args[0]);      List<Double> lst = new ArrayList<Double>(n);      for (int i = 1; i <= n; i++) lst.add(Math.random());      while (lst.size() > 2) {    	  Double smallest = Collections.min(lst);    	  Double largest = Collections.max(lst);    	  lst.remove(smallest);    	  lst.remove(largest);      }      double median = 0;      if (lst.size() == 2) {    	  median = (lst.get(0) + lst.get(1)) / 2;      }      else if (lst.size() == 1)      {	 median = lst.get(0);      }      System.out.println("Median: " + median);   }}4. Median: 0.49528759656781435.This is reasonable because the random call when initiating the list calls a number between 0.0 and 1.0.6.10000 1s  100000 20s7.See Scribe8. import java.util.Collections;import java.util.List;import java.util.ArrayList;public class Median2{   public static void main(String[] args)   {      int n = Integer.parseInt(args[0]);      List<Double> lst = new ArrayList<Double>(n);      for (int i = 1; i <= n; i++) lst.add(Math.random());      System.out.println("Median: " + median(lst));   }   public static double median(List<Double> lst)   {      while (lst.size() > 2) {    	  int smallestPosition = 0;    	  int largestPosition = 0;    	  for (int i = 1; i < lst.size(); i++) {    		  if (lst.get(i) < lst.get(smallestPosition)) smallestPosition = i;    		  if (lst.get(i) > lst.get(largestPosition)) largestPosition = i;    	  }    	  int size = lst.size();    	  lst.set(largestPosition, lst.get(size - 1));    	  lst.set(smallestPosition, lst.get(size - 2));    	  lst.remove(size - 1);    	  lst.remove(size - 2);      }      if (lst.size() == 2) {    	  return (lst.get(0) + lst.get(1)) / 2;      }      else if (lst.size() == 1) {      return lst.get(0);      }      else return 0;   }}9.10000   1s  100000  18s10.On2PartCSorry didn’t have timePartD1.This is so because you would just call the remove first and the remove last methods inside the while loop.2.Collections.sort3. import java.util.Collections;import java.util.List;import java.util.ArrayList;public class Median2{   public static void main(String[] args)   {      int n = Integer.parseInt(args[0]);      List<Double> lst = new ArrayList<Double>(n);      for (int i = 1; i <= n; i++) lst.add(Math.random());      System.out.println("Median: " + median(lst));   }   public static double median(List<Double> lst)   {	   Collections.sort(lst);      while (lst.size() > 2) {    	  lst.remove(0);    	  lst.remove(lst.size()-1);      }      if (lst.size() == 2) {    	  return (lst.get(0) + lst.get(1)) / 2;      }      else if (lst.size() == 1) {      return lst.get(0);      }      else return 0;   }}4.10000  .2s   100000  2s5.O(nlog(n))PartE1.The median would be in the first partition because it is longer than the other2.In this array it woulf be the 5th element in the first partition3.O(n)4. 4 1 2 9 9 9 9 9 9 => 1 2 | 4 9 9 9 9 9 95. select(k, 0, n - 1) = select(0, p + 1, n - 1) if p = partition(0, n - 1) and k > p6.When we reach k if its in the first partition