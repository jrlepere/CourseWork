import java.util.LinkedList;
import java.util.List;
import java.util.Random;

/**
 * A class to define the specific eight puzzle problem.
 * @author JLepere2
 * @date 01/25/2018
 */
public class Problem {

	/**
	 * Creates a Problem instance.
	 * @param tileSequence a int[9] array representing the tile locations:
	 *    1 3 8
	 *    9 5 0  => [1,3,8,9,5,0,7,6,2]
	 *    7 6 2
	 *    where 0 is the blank tile.
	 */
	public Problem(int[] tileSequence) {
		this.tileLocations = tileSequence;
	}
	
	/**
	 * Gets the initial child.
	 * @return the initial node.
	 */
	public Node getInitialChild() {
		if (this.tileLocations == null) {
			// Generate random sequence
			// TODO: Test Viable Sequence
			this.tileLocations = new int[9];
			for (int i = 0; i < this.tileLocations.length; i ++) {
				int v = gen.nextInt(this.tileLocations.length);
				boolean unique = true;
				for (int j = 0; j < i; j ++) {
					if (this.tileLocations[j] == v) {
						unique = false;
					}
				}
				if (unique) {
					this.tileLocations[i] = v;
				} else {
					i -= 1;
				}
			}
		}
		return new Node(new State(this.tileLocations), null, null);
	}
	
	/**
	 * Gets the possible Actions from this State
	 * @param s the state
	 * @return a list of actions possible for this state
	 */
	public List<IAction> getActions(State s) {
		List<IAction> actions = new LinkedList<>();
		MoveBlankTile up = new MoveBlankTile(MoveBlankTile.Direction.UP);
		MoveBlankTile right = new MoveBlankTile(MoveBlankTile.Direction.RIGHT);
		MoveBlankTile down = new MoveBlankTile(MoveBlankTile.Direction.DOWN);
		MoveBlankTile left = new MoveBlankTile(MoveBlankTile.Direction.LEFT);
		if (up.canExecute(s)) actions.add(up);
		if (right.canExecute(s)) actions.add(right);
		if (down.canExecute(s)) actions.add(down);
		if (left.canExecute(s)) actions.add(left);
		return actions;
	}
	
	/**
	 * Tests if the passed state is a goal state.
	 * @param s the state
	 * @return true if the state is a goal state, false otherwise
	 */
	public boolean isGoalState(State s) {
		int[] goal = {0,1,2,3,4,5,6,7,8};
		return s.getTileLocations().equals(goal);
	}
	
	/**
	 * The first heuristic function.
	 * @param s the state
	 * @return the result of executing the first heuristic function on the state
	 */
	public int heuristicOne(State s) {
		int[] tileLocations = s.getTileLocations();
		int misplacedTilesCount = 0;
		for (int i = 0; i < tileLocations.length; i ++) {
			if (tileLocations[i] != i) {
				misplacedTilesCount += 1;
			}
		}
		return misplacedTilesCount;
	}
	
	Random gen = new Random();
	private int[] tileLocations;
	
}
